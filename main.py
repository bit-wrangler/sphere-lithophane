import numpy as np
from PIL import Image
import struct
import math
import os

# ==========================================
# CONSTANTS (User Configurable)
# ==========================================

# Path to your downloaded NASA CGI Moon Kit TIFF/JPG
INPUT_IMAGE = "lroc_color_poles_2k.tif" 
OUTPUT_STL = "moon_lithophane.stl"

# Image processing
# True: Darker pixels = Thicker (Standard for photo lithophanes)
# False: Brighter pixels = Thicker (Standard for elevation maps/globes)
INVERT_IMAGE = True 

# Dimensions in mm
SPHERE_DIAMETER = 150.0  # Outer diameter of the moon sphere
MIN_THICKNESS = 0.4*2      # Thinnest part of the shell (brightest/darkest spots)
MAX_THICKNESS = MIN_THICKNESS + 0.4*4     # Thickest part of the shell

# Mounting Cylinder Dimensions
CYLINDER_ID = 65.0       # Inner Diameter of the hole/cylinder
CYLINDER_OD = CYLINDER_ID + 3*2       # Outer Diameter of the cylinder
CYLINDER_HEIGHT = 10.0   # Height of the cylinder extending from the moon
FLANGE_OD = CYLINDER_OD + 3*2         # Outer Diameter of the bottom flange
FLANGE_THICKNESS = 3.0   # Thickness of the flange

# Resolution scaling (Downscale image to prevent massive STL files)
# A width of 1000-2000 is usually sufficient for 3D printing.
TARGET_WIDTH = 500 

# ==========================================
# SCRIPT IMPLEMENTATION
# ==========================================

def weld_vertices(triangles, tolerance=1e-6):
    """
    Weld vertices that are within tolerance to ensure manifold geometry.
    Returns triangles with welded vertex references.
    """
    print("Welding vertices to fix non-manifold geometry...")

    # Collect all vertices
    all_vertices = []
    for t in triangles:
        for v in t:
            all_vertices.append(tuple(v))

    # Round vertices to eliminate floating-point precision issues
    # Use a grid-based approach for fast vertex merging
    vertex_map = {}  # Maps rounded vertex tuple to canonical vertex
    unique_vertices = []

    decimals = int(-np.log10(tolerance))

    for v in all_vertices:
        # Round to tolerance
        key = tuple(np.round(v, decimals=decimals))
        if key not in vertex_map:
            vertex_map[key] = np.array(v)
            unique_vertices.append(np.array(v))

    print(f"Reduced {len(all_vertices)} vertices to {len(unique_vertices)} unique vertices")

    # Rebuild triangles with welded vertices
    welded_triangles = []
    for t in triangles:
        new_tri = []
        for v in t:
            key = tuple(np.round(v, decimals=decimals))
            new_tri.append(vertex_map[key])
        welded_triangles.append(new_tri)

    return welded_triangles


def write_stl(triangles, filename):
    """Writes a list of triangles to a binary STL file."""
    # Weld vertices first to ensure manifold geometry
    triangles = weld_vertices(triangles)

    print(f"Writing STL to {filename} ({len(triangles)} triangles)...")
    with open(filename, "wb") as f:
        # 80 byte header
        header = b"Generated by Python Moon Lithophane Script"
        f.write(header.ljust(80, b'\x00'))
        # Number of triangles
        f.write(struct.pack("<I", len(triangles)))

        # Write triangles
        # Format: Normal(3f), Vertex1(3f), Vertex2(3f), Vertex3(3f), Attribute(2 bytes)
        # We calculate normals or just leave them 0 (slicers usually recalculate)
        zeros = struct.pack("<H", 0)
        for t in triangles:
            # Simple normal calculation (optional, but good practice)
            v1, v2, v3 = t
            edge1 = v2 - v1
            edge2 = v3 - v1
            cross = np.cross(edge1, edge2)
            norm = np.linalg.norm(cross)
            if norm > 0:
                normal = cross / norm
            else:
                normal = np.array([0, 0, 0])

            f.write(struct.pack("<3f", *normal))
            f.write(struct.pack("<3f", *v1))
            f.write(struct.pack("<3f", *v2))
            f.write(struct.pack("<3f", *v3))
            f.write(zeros)
    print("Done.")

def generate_mesh():
    print(f"Loading image: {INPUT_IMAGE}")
    try:
        img = Image.open(INPUT_IMAGE).convert('L') # Convert to Grayscale
    except FileNotFoundError:
        print(f"Error: Could not find {INPUT_IMAGE}. Please ensure the file exists.")
        return

    # Resize image to manage mesh density
    aspect_ratio = img.height / img.width
    new_width = TARGET_WIDTH
    new_height = int(new_width * aspect_ratio)
    img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
    
    # Get pixel data
    pixels = np.array(img) / 255.0 # Normalize 0-1
    if INVERT_IMAGE:
        pixels = 1.0 - pixels

    rows, cols = pixels.shape
    print(f"Image grid: {cols}x{rows}")

    # Geometry Calculation
    # --------------------
    
    # Calculate Base Radius (Inner Surface)
    # We treat SPHERE_DIAMETER as the nominal Outer Diameter.
    # To ensure it fits, we set the Inner Radius such that the shell builds OUTWARDS? 
    # Or Inner Radius fixed, Outer varies. 
    # Let's assume SPHERE_DIAMETER is the max outer bounds.
    R_base = (SPHERE_DIAMETER / 2.0) - MAX_THICKNESS

    # Determine Cutoff Angle for the Hole
    # We want the hole chord to match CYLINDER_OD (to attach the cylinder walls)
    # R * sin(angle_from_pole) = OD / 2
    # angle_from_pole = arcsin(OD / (2*R))
    # Note: We use R_base for the safe cutoff calculation
    
    # Safety check
    if CYLINDER_OD > SPHERE_DIAMETER:
        raise ValueError("Cylinder OD cannot be larger than Sphere Diameter")

    pole_angle = np.arcsin(CYLINDER_OD / (2 * (R_base + MIN_THICKNESS)))
    
    # Latitude range: -pi/2 (South) to pi/2 (North)
    # But image maps 0 (Top) to pi/2 and Height (Bottom) to -pi/2
    # We stop the mesh generation before reaching the south pole (-pi/2)
    # Cutoff latitude = -pi/2 + pole_angle
    
    lat_min = -np.pi/2 + pole_angle
    
    # We only process rows that are above this latitude
    # Map row index to latitude: lat = pi/2 - (row / rows) * pi
    # Find row index where lat < lat_min
    row_limit = int(rows * (1 - (lat_min + np.pi/2)/np.pi))
    
    print(f"Generating Sphere Mesh up to row {row_limit}/{rows}...")

    # Generate Grid
    # Add +1 to cols to wrap around texture (u=0 and u=1)
    phi = np.linspace(0, 2*np.pi, cols + 1) # Longitude
    # Latitude for the used rows
    theta = np.linspace(np.pi/2, lat_min, row_limit + 1) # Latitude
    
    phi_grid, theta_grid = np.meshgrid(phi, theta)
    
    # Map pixels to thickness
    # We need to stretch pixel data to match the +1 col grid and limited rows
    # Simple nearest neighbor or interpolation for the mesh points
    # For simplicity in this script, we map grid vertices to image UVs
    
    # UV Coordinates
    u = np.linspace(0, 1, cols + 1)
    v = np.linspace(0, (row_limit)/rows, row_limit + 1) # V goes 0 to 1
    
    # Sample intensities
    # We map u,v to pixel coordinates
    pixel_x = (u * (cols - 1)).astype(int)
    pixel_y = (v * (rows - 1)).astype(int)
    
    # Wrap pixel_x: last column should match first pixel column usually? 
    # Actually u=1 maps to width. Clamp.
    pixel_x = np.clip(pixel_x, 0, cols-1)
    pixel_y = np.clip(pixel_y, 0, rows-1)
    
    px_grid, py_grid = np.meshgrid(pixel_x, pixel_y)
    intensities = pixels[py_grid, px_grid] # Shape: (row_limit+1, cols+1)

    # Calculate Radii
    thickness_map = MIN_THICKNESS + intensities * (MAX_THICKNESS - MIN_THICKNESS)
    r_outer = R_base + thickness_map
    r_inner = np.full_like(r_outer, R_base)

    # Spherical to Cartesian
    def sph2cart(r, th, ph):
        x = r * np.cos(th) * np.cos(ph)
        y = r * np.cos(th) * np.sin(ph)
        z = r * np.sin(th)
        return x, y, z

    xo, yo, zo = sph2cart(r_outer, theta_grid, phi_grid)
    xi, yi, zi = sph2cart(r_inner, theta_grid, phi_grid)

    # Ensure the seam is closed: last column must exactly match first column
    # This prevents non-manifold edges at the phi=0/2pi seam
    xo[:, -1] = xo[:, 0]
    yo[:, -1] = yo[:, 0]
    zo[:, -1] = zo[:, 0]
    xi[:, -1] = xi[:, 0]
    yi[:, -1] = yi[:, 0]
    zi[:, -1] = zi[:, 0]

    # Build Triangles
    triangles = []
    
    print("Triangulating Sphere...")
    # Grid consists of quads. Split into 2 triangles.
    # Outer Shell (CCW)
    for r in range(row_limit):
        for c in range(cols):
            # Indices
            # Top-Left: r, c
            # Bottom-Right: r+1, c+1
            
            # Vertices Outer
            p1 = np.array([xo[r,c], yo[r,c], zo[r,c]])
            p2 = np.array([xo[r,c+1], yo[r,c+1], zo[r,c+1]])
            p3 = np.array([xo[r+1,c+1], yo[r+1,c+1], zo[r+1,c+1]])
            p4 = np.array([xo[r+1,c], yo[r+1,c], zo[r+1,c]])
            
            # Triangle 1
            triangles.append([p1, p4, p2])
            # Triangle 2
            triangles.append([p2, p4, p3])
            
            # Vertices Inner (CW - facing in)
            ip1 = np.array([xi[r,c], yi[r,c], zi[r,c]])
            ip2 = np.array([xi[r,c+1], yi[r,c+1], zi[r,c+1]])
            ip3 = np.array([xi[r+1,c+1], yi[r+1,c+1], zi[r+1,c+1]])
            ip4 = np.array([xi[r+1,c], yi[r+1,c], zi[r+1,c]])
            
            # Triangle 1 (Reversed order for inner normals)
            triangles.append([ip1, ip2, ip4])
            # Triangle 2
            triangles.append([ip2, ip3, ip4])

    # ==========================================
    # CYLINDER & FLANGE GENERATION
    # ==========================================
    print("Generating Cylinder and Flange...")
    
    # We need to connect the bottom loop of the sphere to the cylinder
    # Sphere bottom loop index is `row_limit`
    
    # Cylinder Z levels
    z_join = zi[row_limit, 0] # Approximate Z level of the cut (from inner sphere)
    # Actually, the outer sphere z varies, inner is constant.
    # We will bridge from the jagged outer edge and smooth inner edge to the cylinder.
    
    z_cyl_top = z_join
    z_flange_top = z_join - CYLINDER_HEIGHT
    z_flange_bot = z_flange_top - FLANGE_THICKNESS
    
    # Radii
    cyl_ri = CYLINDER_ID / 2.0
    cyl_ro = CYLINDER_OD / 2.0
    flg_ro = FLANGE_OD / 2.0
    
    # Generate Cylinder Ring Points
    # matches the 'phi' resolution
    cyl_angles = phi 
    
    def get_ring(r, z, angles):
        x = r * np.cos(angles)
        y = r * np.sin(angles)
        zs = np.full_like(x, z)
        ring = np.column_stack((x, y, zs))
        # Ensure the ring is closed: last vertex must exactly match first
        ring[-1] = ring[0].copy()
        return ring

    # Rings
    # 1. Sphere Bottom Outer (Variable R, Variable Z) -> Already in xo, yo, zo at row_limit
    sphere_bot_out = np.column_stack((xo[row_limit], yo[row_limit], zo[row_limit]))
    
    # 2. Sphere Bottom Inner (Constant R, Constant Z) -> Already in xi, yi, zi at row_limit
    sphere_bot_in = np.column_stack((xi[row_limit], yi[row_limit], zi[row_limit]))
    
    # 3. Cylinder Top Outer
    cyl_top_out = get_ring(cyl_ro, z_cyl_top, cyl_angles)
    
    # 4. Cylinder Top Inner
    cyl_top_in = get_ring(cyl_ri, z_cyl_top, cyl_angles)
    
    # 5. Flange Top Outer (at Cylinder OD)
    flange_neck = get_ring(cyl_ro, z_flange_top, cyl_angles)
    
    # 6. Flange Top Edge (at Flange OD)
    flange_top_edge = get_ring(flg_ro, z_flange_top, cyl_angles)
    
    # 7. Flange Bottom Edge
    flange_bot_edge = get_ring(flg_ro, z_flange_bot, cyl_angles)
    
    # 8. Flange Bottom Inner (Hole at bottom)
    flange_hole = get_ring(cyl_ri, z_flange_bot, cyl_angles)

    # Stitching Functions
    def stitch_rings(ring_upper, ring_lower, flip=False):
        # Stitches two rings of points
        tris = []
        for i in range(len(ring_upper) - 1):
            p1 = ring_upper[i]
            p2 = ring_upper[i+1]
            p3 = ring_lower[i+1]
            p4 = ring_lower[i]
            
            if not flip:
                tris.append([p1, p4, p2])
                tris.append([p2, p4, p3])
            else:
                tris.append([p1, p2, p4])
                tris.append([p2, p3, p4])
        return tris

    # 1. Bridge Sphere Outer to Cylinder Top Outer
    triangles.extend(stitch_rings(sphere_bot_out, cyl_top_out))
    
    # 2. Bridge Sphere Inner to Cylinder Top Inner (Flip for inner surface)
    # Note: Sphere Inner is "facing in", Cylinder Inner should "face in" to the hole
    # So we connect them. The normal depends on view.
    # Let's consider the solid wall: 
    # Wall is between Inner and Outer.
    # Sphere Inner Mesh was generated CW. 
    # Let's treat the Adapter as a solid block added.
    
    # Cylinder Outer Wall
    triangles.extend(stitch_rings(cyl_top_out, flange_neck))
    
    # Cylinder Inner Wall (Hole) - Face Inwards
    # Connect Cyl Top Inner to Flange Hole
    triangles.extend(stitch_rings(cyl_top_in, flange_hole, flip=True))
    
    # Bridge Sphere Inner Edge to Cylinder Top Inner Edge
    # Sphere Inner Edge points are "inside" the sphere. 
    # We need to close the gap between Sphere Inner Shell and Cylinder Inner Wall
    # Sphere Inner Mesh normals point to center.
    triangles.extend(stitch_rings(sphere_bot_in, cyl_top_in, flip=True))
    
    # Flange Top Face
    triangles.extend(stitch_rings(flange_neck, flange_top_edge))
    
    # Flange Outer Wall
    triangles.extend(stitch_rings(flange_top_edge, flange_bot_edge))
    
    # Flange Bottom Face
    triangles.extend(stitch_rings(flange_bot_edge, flange_hole, flip=True)) # Face down

    # Finalize
    write_stl(triangles, OUTPUT_STL)

if __name__ == "__main__":
    generate_mesh()